PUBLIC NEWSTR
PUBLIC OUTPUT_SIGN_HEX
PUBLIC OUTPUT_UNSIGN_DEC

EXTRN DEC_NUMBER: WORD
EXTRN HEX_NUMBER: BYTE
EXTRN BIN_TO_DEC: NEAR
EXTRN BIN_TO_HEX: NEAR


; Сегмент данных
DATAS SEGMENT PARA PUBLIC 'DATA'
	OUTPUT_DEC_MSG DB 'Unsigned decimal number: $'
	OUTPUT_HEX_MSG DB 'Signed hexadecimal number: $'
	DEC_NUMBER_DIGITS DB 5 DUP(0)
	DIGITS_COUNT DW 0
DATAS ENDS	

; Сегмент кода
CODES SEGMENT PARA PUBLIC 'CODE'	
    ASSUME CS:CODES, DS:DATAS
	
; Перевод на новую строку
NEWSTR PROC NEAR
	MOV AH, 2
	MOV DL, 13
	INT 21h
	MOV DL, 10
	INT 21h
	RET
NEWSTR ENDP

OUTPUT_UNSIGN_DEC PROC NEAR
	MOV DX, OFFSET OUTPUT_DEC_MSG
	MOV AH, 9
	INT 21h
	
	CALL BIN_TO_DEC
	
	CALL OUTPUT_DEC_NUMBER
	
	CALL NEWSTR
	CALL NEWSTR
	RET
OUTPUT_UNSIGN_DEC ENDP


OUTPUT_SIGN_HEX PROC NEAR
	MOV DX, OFFSET OUTPUT_HEX_MSG
	MOV AH, 9
	INT 21h

	CALL BIN_TO_HEX

	CALL OUTPUT_HEX_NUMBER
	
	CALL NEWSTR
	CALL NEWSTR
	RET
OUTPUT_SIGN_HEX ENDP

OUTPUT_DEC_NUMBER PROC NEAR
	MOV CX, 1
	MOV SI, 0
	DIV_LOOP:
		XOR DX, DX
		MOV AX, DEC_NUMBER
		MOV BX, 10 
		DIV BX ;  остаток лежит в DX
		MOV DEC_NUMBER, AX
		MOV DEC_NUMBER_DIGITS[SI], DL
		INC SI
		CMP DEC_NUMBER, 0
		JE REVERSE_DEC_NUMBER
		INC CX
		loop DIV_LOOP
	REVERSE_DEC_NUMBER:
		MOV DIGITS_COUNT, SI
		XOR DX, DX ; высчитываем сколько раз нужно выполнить цикл
		MOV AX, DIGITS_COUNT
		MOV BX, 2
		DIV BX
		MOV CX, AX
		CMP CX, 0
		JE PRINT
		MOV SI, 0
		MOV BX, DIGITS_COUNT
		REVERSE_LOOP: ; переворачиваем число
			MOV AL, DEC_NUMBER_DIGITS[SI]
			XOR AH, AH
			MOV BX, DIGITS_COUNT
			DEC BX
			SUB BX, SI
			MOV DL, DEC_NUMBER_DIGITS[BX]
			XOR DH, DH
			MOV DEC_NUMBER_DIGITS[SI], DL
			MOV DEC_NUMBER_DIGITS[BX], AL
			INC SI
			DEC BX
			loop REVERSE_LOOP
		PRINT: ; печать числа
			MOV CX, DIGITS_COUNT
			MOV SI, 0
			PRINT_LOOP:
				ADD DEC_NUMBER_DIGITS[SI], '0'
				MOV DL, DEC_NUMBER_DIGITS[SI]
				XOR DH, DH
				MOV AH, 2
				INT 21h
				INC SI
				loop PRINT_LOOP
		RET
OUTPUT_DEC_NUMBER ENDP

OUTPUT_HEX_NUMBER PROC NEAR
	MOV SI, 0
	MOV DL, HEX_NUMBER[SI]; печатаем знак
	MOV AH, 2
	INT 21h
	INC SI

	MOV CX, 4
	SKIP_ZEROES: ; не печатаем незначащие нули
		CMP HEX_NUMBER[SI], '0'
		JNE HEX_PRINT_LOOP
		INC SI
		loop SKIP_ZEROES

	CMP SI, 0
	JE OUTPUT_HEX_NUMBER_EXIT

	HEX_PRINT_LOOP:
		MOV DL, HEX_NUMBER[SI]
		MOV AH, 2
		INT 21h
		INC SI
		loop HEX_PRINT_LOOP

	OUTPUT_HEX_NUMBER_EXIT:	
		RET
OUTPUT_HEX_NUMBER ENDP

CODES ENDS
END